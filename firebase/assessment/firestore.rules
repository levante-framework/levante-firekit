rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow users to create, read, and write to their own data
    // Because we use the top level collection to separate development from production,
    // We use the dev_collection and dev_document wildcards to catch both
    // production and dev databases
    match /{dev_collection}/{dev_document} {
    
      function isCiUser() {
        return request.auth.uid == '5bxhS2oSJSclAfYLMheAJV8C8B53';
      }
      
      function isLoggedIn() {
 			  return request.auth != null;
			}
      
      function isRole(role) {
  			return isLoggedIn() && request.auth.uid in get(/databases/$(database)/documents/admin/$(role)).data.users
			}
      
      function canRead() {
      	return isCiUser() || isRole("researchers") || isRole("admins");
      }
      
      allow read: if canRead();
      allow write: if false;

      match /users/{userId} {
      	function myData() {
        	return request.auth != null && request.auth.uid == get(/databases/$(database)/documents/$(dev_collection)/$(dev_document)/users/$(userId)).data.firebaseUid
    		}
        
      	function canWrite() {
        	return myData() || isCiUser();
      	}
        
        function canReadTrials() {
          return myData() || canRead();
        }
      
	      allow create: if request.auth != null && request.auth.uid == request.resource.data.firebaseUid;
        allow update: if request.auth != null && request.auth.uid == resource.data.firebaseUid;
        allow delete: if isCiUser();
  	    allow read: if canRead();
                
        // Explicitly define rules for the "runs" subcollection
        match /runs/{runId} {
          allow write: if canWrite();
          allow read: if canRead();
          
          match /trials/{trialId} {
          	allow write: if canWrite();
            allow read: if canReadTrials();
          }
        }
      }
      
      match /corpora/{corpusId}/{document=**} {
        allow read: if canRead();
        allow write: if false;
      }
      
      match /tasks/{taskId} {
        function isUpdateToOnly(allowedFields) {
          return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields);
        }

        allow read: if request.auth != null;
        allow create: if request.auth != null;
        allow update: if request.auth != null && isUpdateToOnly(['description', 'lastUpdated']);
        allow delete: if isCiUser();
        
        match /variants/{variantId} {
          allow read: if request.auth != null;
          allow create: if request.auth != null;
          allow update: if request.auth != null && isUpdateToOnly(['lastPlayed', 'description', 'srcHash']);
          allow delete: if isCiUser();
        }
      }
      
      match /districts/{districtId}/{document=**} {
        allow read: if canRead();
        allow write: if false;
      }
      
      match /studies/{studyId}/{document=**} {
        allow read: if canRead();
        allow write: if false;
      }
    }
    
    // Allow anyone to read (but not write) to the list of authorized UIDs
    match /admin/{user_type} {
      allow read: if request.auth != null;
      allow write: if false;
    }
    
    // Anyone can add a request to become an authorized user
    // But they can only use ArrayUnion, adding a single UID to the list
    match /admin/requests {
      allow create: if false;
      allow read: if request.auth != null;
      allow update: if (
          request.resource.data.users.size() == resource.data.users.size() + 1
          && request.resource.data.users.hasAll(resource.data.users)
      );
      allow delete: if false;
    }
  }
}
