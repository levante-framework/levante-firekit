rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Legacy CI user that is like a super_admin
    // TODO: Deprecate this user in favor of using the Firestore emulator for CI
    function isCiUser() {
      return request.auth.uid == '5bxhS2oSJSclAfYLMheAJV8C8B53';
    }

    // Allow super_admins to do everything
    match /{everythingInMyDatabase=**} {
      allow read: if request.auth.token.super_admin == true || isCiUser();
      allow write: if request.auth.token.super_admin == true;
    }

    function loggedIn() {
      return request.auth != null;
    }

    function roarUid() {
      return request.auth.token.roarUid;
    }

    function assessmentUid() {
      return request.auth.token.assessmentUid;
    }

    // The auth token has a custom claim for the organizations that the user is
    // an admin for. The expected data structure is
    // token.adminOrgs = {
    //   districts?: string[],
    //   schools?: string[],
    //   classes?: string[],
    //   families?: string[],
    //   studies?: string[],
    // }
    function getAdminList(orgType) {
      return request.auth.token.get(adminOrgs, {}).get(orgType, []).toSet();
    }

    function usersOrgIsInAdminList(orgType, orgIds) {
      return getAdminList(orgType).hasAny(orgIds);
    }

    // We use the userClaims collection to store refresh timestamps to propogate
    // custom user claims back to the client.
    match /userClaims/{uid} {
      allow get: if loggedIn() && uid == request.auth.uid;
      allow write: if false; // Only write in cloud functions using admin SDK
    }
    
    // We use the top level collection to separate development from production.
    // We therefore use the dev_collection and dev_document wildcards to catch both
    // production and dev databases
    match /{dev_collection}/{dev_document} {
      // Allow users to create, read, and write to their own data or data for users under their admin control

      function getOrgs(orgType) {
        return get(/databases/$(database)/documents/$(dev_collection)/$(dev_document)/users/$(roarUid())).data.get(orgType, []);
      }

      match /users/{uid} {
      	function myData() {
        	return loggedIn() && uid == roarUid();
    		}

        function userIsAdminForThisRoarUid() {
          return loggedIn() && (usersOrgIsInAdminList('districts', resource.data.districts)
          || usersOrgIsInAdminList('schools', resource.data.schools)
          || usersOrgIsInAdminList('classes', resource.data.classes)
          || usersOrgIsInAdminList('families', resource.data.families)
          || usersOrgIsInAdminList('studies', resource.data.studies));
        }

        function requestHasNoSchoolOrgs() {
          return request.resource.data.get('districts', []).size() == 0
          && request.resource.data.get('schools', []).size() == 0
          && request.resource.data.get('classes', []).size() == 0;
        }

        function userIsAdminForNewRoarUid() {
          return loggedIn() && (orgsAreInAdminList('districts', request.resource.data.districts)
          || (orgsAreInAdminList('schools', request.resource.data.schools) && getOrgs('districts').toSet().hasAny(request.resource.data.districts))
          || (orgsAreInAdminList('classes', request.resource.data.classes) && (getOrgs('districts').toSet().hasAny(request.resource.data.districts) || getOrgs('schools').toSet().hasAny(request.resource.data.schools)))
          || (orgsAreInAdminList('families', request.resource.data.families) && requestHasNoSchoolOrgs())
          || (orgsAreInAdminList('studies', request.resource.data.studies) && requestHasNoSchoolOrgs()));
        }

        function canAccessExistingUser() {
          return userIsAdminForThisRoarUid() || myData();
        }

        function canCreateNewUser() {
          return userIsAdminForNewRoarUid() || myData();
        }
        
  	    allow read: if canAccessExistingUser();
	      allow create: if canCreateNewUser();
        allow update: if canAccessExistingUser();
                
        // Explicitly define rules for the "runs" subcollection
        match /runs/{runId} {
          function userIsAdminForThisRunId() {
            return loggedIn() && (usersOrgIsInAdminList('districts', [resource.data.districtId])
            || usersOrgIsInAdminList('schools', [resource.data.schoolId])
            || usersOrgIsInAdminList('classes', [resource.data.classId])
            || usersOrgIsInAdminList('families', [resource.data.familyId])
            || usersOrgIsInAdminList('studies', [resource.data.studyId]));
          }

          function canAccessRun() {
            return userIsAdminForThisRunId() || myData();
          }

          allow write: if myData();
          allow read: if canAccessRun();
          
          match /trials/{trialId} {
          	allow write: if myData();
            allow read: if canAccessRun();
          }
        }
      }
      
      // N.B.: This is a placeholder for tracking the provenance of corpora. We
      // don't currently use it so we lock down access to it.
      match /corpora/{corpusId}/{document=**} {
        allow read: if false;
        allow write: if false;
      }
      
      // Tasks and variants are free for any authenticated user to read and create.
      // Updates are only allowed for certain fields.
      // Only super_admins can update the `registered` field.
      match /tasks/{taskId} {
        function isUpdateToOnly(allowedFields) {
          return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields);
        }

        function registeredFieldIsNotUpdated() {
          return request.resource.data.registered == resource.data.registered;
        }

        function canWrite() {
          return loggedIn() && registeredFieldIsNotUpdated();
        }

        allow read: if loggedIn();
        allow create: if canWrite();
        allow update: if canWrite() && isUpdateToOnly(['description', 'lastUpdated']);
        
        match /variants/{variantId} {
          allow read: if loggedIn();
          allow create: if canWrite();
          allow update: if canWrite() && isUpdateToOnly(['description', 'lastPlayed']);
        }
      }
    }
  }
}
